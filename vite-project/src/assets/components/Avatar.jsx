/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 public/model/untitled.glb -o C:\Users\91827\Desktop\portfolio\vite-project\src\assets\components\Avatar.jsx -k -r public 
*/

import React from 'react'
import { useGraph, useFrame, useThree } from '@react-three/fiber'
import { useGLTF, useAnimations, useFBX } from '@react-three/drei'
import { SkeletonUtils } from 'three-stdlib'
import { useEffect, useState ,useRef} from 'react'
import * as THREE from 'three'
 
export function Model(props) {
  
  const { scene }= useGLTF('/model/untitled.glb')
  const clone = React.useMemo(() => SkeletonUtils.clone(scene), [scene])
  const { nodes, materials } = useGraph(clone)
   
  const {animations:walkinganimation} =useFBX('/animation/Walking.fbx')
  const {animations:idle} =useFBX('/animation/idle.fbx')
  const {animations:falldeath} =useFBX('/animation/Standing React Death Right.fbx')
  idle[0].name = "Idle";
  walkinganimation[0].name = "Walking";
  falldeath[0].name = "falldeath";
  console.log(falldeath)
  const group = useRef();
  const { actions } = useAnimations(
    [idle[0], walkinganimation[0], falldeath[0]],
    group
  );
  const [animation, setAnimation] = useState("Idle");
  const [rotationY, setRotationY] = useState(0);
  const [modelPosition, setModelPosition] = useState([0, 0, 0]);
  const { camera } = useThree();
  const initialCameraPosition = React.useRef(null);

  useEffect(() => {
    const handleKeyDown = (e) => {
      if (e.repeat) return; // Prevent auto-repeat
      if (e.key === "w" || e.key === "W" || e.key === "ArrowUp") {
        // Prevent walking forward if at or beyond z=60
        if (group.current && group.current.position.z >= 60) {
          setAnimation("falldeath"); // or setAnimation("YourBoundaryAnim")
          return;
        }
        setAnimation("Walking");
        setRotationY(0);
      }
      if (e.key === "s" || e.key === "S" || e.key === "ArrowDown") {
        // Prevent walking backward if at or below z=-20
        if (group.current && group.current.position.z <= -10) {
          setAnimation("falldeath"); // or setAnimation("YourBoundaryAnim")
          return;
        }
        setRotationY(Math.PI);
        setAnimation("Walking");
      }
    };
    const handleKeyUp = (e) => {
      if (e.key === "w" || e.key === "W" || e.key === "ArrowUp") {
        setAnimation("Idle");
      }
      if (e.key === "s" || e.key === "S" || e.key === "ArrowDown") {
        setRotationY(0);
        setAnimation("Idle");
      }
    };
    window.addEventListener("keydown", handleKeyDown);
    window.addEventListener("keyup", handleKeyUp);
    return () => {
      window.removeEventListener("keydown", handleKeyDown);
      window.removeEventListener("keyup", handleKeyUp);
    };
  }, []);

  useEffect(() => {
    if (!initialCameraPosition.current) {
      initialCameraPosition.current = camera.position.clone();
    }
  }, [camera]);

  useEffect(() => {
    if (!actions[animation]) return;
    actions[animation].reset().fadeIn(0).play();
    return () => {
      if (actions[animation]) actions[animation].fadeOut(0);
    };
  }, [animation, actions]);

  useFrame((_, delta) => {
    if (!group.current) return;
    
    // Ensure animation speed is always normal
    if (actions && actions[animation]) {
      actions[animation].setEffectiveTimeScale(1);
    }
    
    // Move forward/backward based on animation and rotationY
    if (animation === "Walking") {
      const speed = 4;
      const forward = new THREE.Vector3(0, 0, 1);
      forward.applyAxisAngle(new THREE.Vector3(0, 1, 0), rotationY);
      forward.multiplyScalar(speed * delta);

      // Clamp movement within boundaries
      const nextZ = group.current.position.z + forward.z;
      if (
        (rotationY === 0 && nextZ > 60) || // forward
        (rotationY === Math.PI && nextZ < -20) // backward
      ) {
        // Prevent movement beyond boundaries
        setAnimation("Idle"); // or setAnimation("YourBoundaryAnim")
        return;
      }
      group.current.position.add(forward);
    }
    
    // Reset root bone position to prevent animation snap/lag
    if (nodes.rp_nathan_animated_003_walking_root) {
      nodes.rp_nathan_animated_003_walking_root.position.set(0, 0, 0);
    }
    
    // Camera follow logic: keep x/y fixed, move z with model
    if (initialCameraPosition.current) {
      camera.position.x = initialCameraPosition.current.x;
      camera.position.y = initialCameraPosition.current.y;
      camera.position.z = initialCameraPosition.current.z + group.current.position.z;
      camera.lookAt(group.current.position.x, group.current.position.y + 1, group.current.position.z);
    }
  });
  
  return (
    <group ref={group} {...props} dispose={null}>
      <group name="Scene">
        <group
          name="rp_nathan_animated_003_walking"
          rotation={[0, rotationY, 0]}
          scale={0.009}
        >
          <group name="rp_nathan_animated_003_walking_CTRL">
            <group name="Armature">
              <primitive object={nodes.rp_nathan_animated_003_walking_root} />
              <skinnedMesh name="rp_nathan_animated_003_walking_geo" geometry={nodes.rp_nathan_animated_003_walking_geo.geometry} material={materials.rp_nathan_animated_003_mat} skeleton={nodes.rp_nathan_animated_003_walking_geo.skeleton} />
            </group>
          </group>
          <group name="rp_nathan_animated_003_walking_geoGRP" />
        </group>
      </group>
    </group>
  )
}


useGLTF.preload('/model/untitled.glb')
useFBX.preload('/animation/idle.fbx')
useFBX.preload('/animation/Walking.fbx')
useFBX.preload('/animation/Standing React Death Right.fbx')
useFBX.preload('/animation/YourBoundaryAnim.fbx')
export default Model
