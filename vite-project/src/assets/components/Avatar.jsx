/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 public/model/untitled.glb -o C:\Users\91827\Desktop\portfolio\vite-project\src\assets\components\Avatar.jsx -k -r public 
*/

import React from 'react'
import { useGraph, useFrame, useThree } from '@react-three/fiber'
import { useGLTF, useAnimations, useFBX } from '@react-three/drei'
import { SkeletonUtils } from 'three-stdlib'
import { useEffect, useState ,useRef} from 'react'
import * as THREE from 'three'
 
export function Model(props) {
  const { isMobile } = props; // Accept isMobile prop
  
  const { scene }= useGLTF('/model/untitled.glb')
  const clone = React.useMemo(() => SkeletonUtils.clone(scene), [scene])
  const { nodes, materials } = useGraph(clone)
   
  const {animations:walkinganimation} =useFBX('/animation/Walking.fbx')
  const {animations:idle} =useFBX('/animation/idle.fbx')
  const {animations:falldeath} =useFBX('/animation/Standing React Death Right.fbx')
  idle[0].name = "Idle";
  walkinganimation[0].name = "Walking";
  falldeath[0].name = "falldeath";
  console.log(falldeath)
  const group = useRef();
  const { actions } = useAnimations(
    [idle[0], walkinganimation[0], falldeath[0]],
    group
  );
  const [animation, setAnimation] = useState("Idle");
  const [rotationY, setRotationY] = useState(0);
  const [modelPosition, setModelPosition] = useState([0, 0, 0]);
  const { camera } = useThree();
  const initialCameraPosition = React.useRef(null);
  const targetCameraPosition = React.useRef(new THREE.Vector3());
  const lastModelPosition = React.useRef(new THREE.Vector3());
  const cameraOffset = React.useRef(null); // Store the initial offset

  useEffect(() => {
    const handleKeyDown = (e) => {
      if (e.repeat) return; // Prevent auto-repeat
      handleMovement(e.key.toLowerCase(), true);
    };

    const handleKeyUp = (e) => {
      handleMovement(e.key.toLowerCase(), false);
    };

    // Handle virtual control events
    const handleCharacterMove = (event) => {
      const { key, isPressed } = event.detail;
      handleMovement(key, isPressed);
    };

    const handleMovement = (key, isPressed) => {
      if (key === "w" || key === "arrowup") {
        if (isPressed) {
          // Prevent walking forward if at or beyond z=60
          if (group.current && group.current.position.z >= 60) {
            setAnimation("falldeath");
            return;
          }
          setAnimation("Walking");
          setRotationY(0);
        } else {
          setAnimation("Idle");
        }
      }
      if (key === "s" || key === "arrowdown") {
        if (isPressed) {
          // Prevent walking backward if at or below z=-20
          if (group.current && group.current.position.z <= -10) {
            setAnimation("falldeath");
            return;
          }
          setRotationY(Math.PI);
          setAnimation("Walking");
        } else {
          setRotationY(0);
          setAnimation("Idle");
        }
      }
      if (key === "a") {
        if (isPressed) {
          setRotationY(-Math.PI / 2);
          setAnimation("Walking");
        } else {
          setAnimation("Idle");
        }
      }
      if (key === "d") {
        if (isPressed) {
          setRotationY(Math.PI / 2);
          setAnimation("Walking");
        } else {
          setAnimation("Idle");
        }
      }
    };

    window.addEventListener("keydown", handleKeyDown);
    window.addEventListener("keyup", handleKeyUp);
    window.addEventListener('characterMove', handleCharacterMove);

    return () => {
      window.removeEventListener("keydown", handleKeyDown);
      window.removeEventListener("keyup", handleKeyUp);
      window.removeEventListener('characterMove', handleCharacterMove);
    };
  }, []);

  useEffect(() => {
    if (!initialCameraPosition.current) {
      initialCameraPosition.current = camera.position.clone();
      targetCameraPosition.current.copy(camera.position);
      // Calculate the initial offset between camera and model (assuming model starts at origin)
      cameraOffset.current = camera.position.z - 0; // Model starts at z=0
    }
  }, [camera]);

  useEffect(() => {
    if (!actions[animation]) return;
    actions[animation].reset().fadeIn(0).play();
    return () => {
      if (actions[animation]) actions[animation].fadeOut(0);
    };
  }, [animation, actions]);

  useFrame((_, delta) => {
    if (!group.current) return;
    
    // Ensure animation speed is always normal
    if (actions && actions[animation]) {
      actions[animation].setEffectiveTimeScale(1);
    }
    
    // Move forward/backward based on animation and rotationY
    if (animation === "Walking") {
      const speed = 4;
      const forward = new THREE.Vector3(0, 0, 1);
      forward.applyAxisAngle(new THREE.Vector3(0, 1, 0), rotationY);
      forward.multiplyScalar(speed * delta);

      // Clamp movement within boundaries
      const nextZ = group.current.position.z + forward.z;
      if (
        (rotationY === 0 && nextZ > 60) || // forward
        (rotationY === Math.PI && nextZ < -20) // backward
      ) {
        // Prevent movement beyond boundaries
        setAnimation("Idle"); // or setAnimation("YourBoundaryAnim")
        return;
      }
      group.current.position.add(forward);
    }
    
    // Reset root bone position to prevent animation snap/lag
    if (nodes.rp_nathan_animated_003_walking_root) {
      nodes.rp_nathan_animated_003_walking_root.position.set(0, 0, 0);
    }
    
    // Smooth camera follow logic with proper interpolation
    if (initialCameraPosition.current && group.current && cameraOffset.current !== null) {
      // Calculate target camera position based on model movement
      const modelPositionDelta = group.current.position.z - lastModelPosition.current.z;
      
      // Update target camera position to maintain constant offset
      targetCameraPosition.current.x = initialCameraPosition.current.x;
      targetCameraPosition.current.y = initialCameraPosition.current.y;
      // Maintain constant offset: camera should always be cameraOffset distance behind the model
      targetCameraPosition.current.z = group.current.position.z + cameraOffset.current;
      
      // Adjust lerp factor for smooth camera movement
      const lerpFactor = Math.min(1, 8 * delta); // Same speed for both mobile and desktop
      camera.position.lerp(targetCameraPosition.current, lerpFactor);
      
      // Update camera look-at target
      const lookAtTarget = new THREE.Vector3(
        group.current.position.x, 
        group.current.position.y + 1, 
        group.current.position.z
      );
      camera.lookAt(lookAtTarget);
      
      // Store current model position for next frame
      lastModelPosition.current.copy(group.current.position);
    }
  });
  
  return (
    <group ref={group} {...props} dispose={null}>
      <group name="Scene">
        <group
          name="rp_nathan_animated_003_walking"
          rotation={[0, rotationY, 0]}
          scale={0.009}
        >
          <group name="rp_nathan_animated_003_walking_CTRL">
            <group name="Armature">
              <primitive object={nodes.rp_nathan_animated_003_walking_root} />
              <skinnedMesh name="rp_nathan_animated_003_walking_geo" geometry={nodes.rp_nathan_animated_003_walking_geo.geometry} material={materials.rp_nathan_animated_003_mat} skeleton={nodes.rp_nathan_animated_003_walking_geo.skeleton} />
            </group>
          </group>
          <group name="rp_nathan_animated_003_walking_geoGRP" />
        </group>
      </group>
    </group>
  )
}


useGLTF.preload('/model/untitled.glb')
useFBX.preload('/animation/idle.fbx')
useFBX.preload('/animation/Walking.fbx')
useFBX.preload('/animation/Standing React Death Right.fbx')
useFBX.preload('/animation/YourBoundaryAnim.fbx')
export default Model
